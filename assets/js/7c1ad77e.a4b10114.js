"use strict";(self.webpackChunkaurora_docs=self.webpackChunkaurora_docs||[]).push([[8244],{9613:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>m});var n=a(9496);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},h=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),u=l(a),p=r,m=u["".concat(c,".").concat(p)]||u[p]||d[p]||o;return a?n.createElement(m,s(s({ref:t},h),{},{components:a})):n.createElement(m,s({ref:t},h))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=p;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[u]="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=a[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},9911:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var n=a(1163),r=(a(9496),a(9613));const o={sidebar_label:"Introduction",title:"Aurora to Near XCC"},s=void 0,i={unversionedId:"xcc/aurora-to-near/introduction",id:"xcc/aurora-to-near/introduction",title:"Aurora to Near XCC",description:"The purpose of this feature is to enable EVM smart contracts on Aurora to interact with Wasm smart contracts in the broader NEAR ecosystem.",source:"@site/docs/xcc/aurora-to-near/introduction.md",sourceDirName:"xcc/aurora-to-near",slug:"/xcc/aurora-to-near/introduction",permalink:"/xcc/aurora-to-near/introduction",draft:!1,editUrl:"https://github.com/aurora-is-near/doc.aurora.dev/edit/master/docs/xcc/aurora-to-near/introduction.md",tags:[],version:"current",frontMatter:{sidebar_label:"Introduction",title:"Aurora to Near XCC"},sidebar:"tutorialSidebar",previous:{title:"Whitelists API",permalink:"/launch-chain/reference/whitelists-api"},next:{title:"Usage examples",permalink:"/xcc/aurora-to-near/usage-examples"}},c={},l=[{value:"Architecture",id:"architecture",level:2},{value:"How to use XCC",id:"how-to-use-xcc",level:2},{value:"How XCC works",id:"how-xcc-works",level:2},{value:"NEAR\u2019s asynchronous environment",id:"nears-asynchronous-environment",level:3},{value:"The identity of an EVM address on NEAR",id:"the-identity-of-an-evm-address-on-near",level:3},{value:"Getting the result of a NEAR call",id:"getting-the-result-of-a-near-call",level:3},{value:"The data structures used by XCC",id:"the-data-structures-used-by-xcc",level:3}],h={toc:l},u="wrapper";function d(e){let{components:t,...o}=e;return(0,r.kt)(u,(0,n.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The purpose of this feature is to enable EVM smart contracts on Aurora to interact with Wasm smart contracts in the broader NEAR ecosystem.\nSince the Aurora EVM is itself a smart contract on NEAR, this feature boils down to cross-contract calls between smart contracts on NEAR, hence the name."),(0,r.kt)("p",null,"Developers might be interested in this feature for any number of reasons; the NEAR ecosystem is large.\nBut for example they may be interested in integrating their dapp with liquidity pools on NEAR (e.g. ",(0,r.kt)("a",{parentName:"p",href:"https://www.ref.finance/"},"ref.finance"),") or NFT marketplaces."),(0,r.kt)("h2",{id:"architecture"},"Architecture"),(0,r.kt)("p",null,"Schematically we can represent Aurora to Near XCC flow with the next picture:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"aurora-near-xcc",src:a(8818).Z})),(0,r.kt)("h2",{id:"how-to-use-xcc"},"How to use XCC"),(0,r.kt)("p",null,"The Aurora EVM has a special precompile address (",(0,r.kt)("inlineCode",{parentName:"p"},"0x516Cded1D16af10CAd47D6D49128E2eB7d27b372"),") which other EVM smart contracts can call to access the XCC feature.\nThis address accepts as input a ",(0,r.kt)("a",{parentName:"p",href:"https://borsh.io/"},"borsh"),"-encoded structure that describes the NEAR call to make.\nThis structure is discussed in more detail below.\nFor convenience, we have developed a Solidity SDK which contains functions for calling the XCC precompile address with the appropriate input.\nSee the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/aurora-is-near/aurora-contracts-sdk/tree/main/examples"},"examples")," for more details on using the SDK with XCC.\nWhen a NEAR call is requested via the XCC precompile, the call is not actually performed until the EVM transaction is complete (for details on why this is the case, see the section below).\nTherefore, unlike normal EVM cross-contract calls, developers cannot simply obtain the output from the XCC and act on it immediately in the same transaction.\nTo get the result of the NEAR call back inside the EVM, you need to attach a callback which triggers the Aurora EVM again after the NEAR call completes.\nThe SDK also contains convenience functions to make this easier, as shown in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/aurora-is-near/aurora-contracts-sdk/tree/main/examples/social-db-from-aurora"},"this example"),".\nNote that the ",(0,r.kt)("inlineCode",{parentName:"p"},"msg.sender")," of the callback will not be equal to the same address that triggered the XCC in the first place.\nThe reason for this is discussed in detail in the following section.\nThe SDK contains a function for computing the sender address that will be used in the callback."),(0,r.kt)("p",null,"In order to use XCC, the address making the NEAR call must have a wrapped NEAR (wNEAR) balance of at least 2 wNEAR.\nThe reason for this is discussed in the following section.\nThe address must also have approved (in the ERC-20 sense) the XCC precompile address to spend that wNEAR.\nThe 2 wNEAR cost is only for the first usage of XCC, after that no further wNEAR is needed (unless the contracts being interacted with require it)."),(0,r.kt)("h2",{id:"how-xcc-works"},"How XCC works"),(0,r.kt)("h3",{id:"nears-asynchronous-environment"},"NEAR\u2019s asynchronous environment"),(0,r.kt)("p",null,"When the XCC precompile address is called, nothing happens immediately.\nThis is to respect the revert semantics of the EVM; a revert should undo any effects caused by a call and any sub-calls it made.\nIf the XCC precompile were to eagerly cause NEAR calls to happen then there would be no way to cancel them in the case of a revert.\nThis is because NEAR cross-contract calls happen asynchronously.\nWhile each synchronous contract execution is atomic, the whole asynchronous transaction is not; if an asynchronous call fails it does not revert the effects of the prior calls that made it.\nFor more information about NEAR transactions in general, see ",(0,r.kt)("a",{parentName:"p",href:"https://docs.near.org/concepts/basics/transactions/overview"},"their documentation"),".\nTherefore, the asynchronous NEAR call a developer requests the XCC precompile to make does not happen until the EVM transaction is complete.\nThis has implications for how to use the result of a NEAR call, as discussed above.\nNamely, the result of a NEAR call must be handled as a callback to the EVM."),(0,r.kt)("h3",{id:"the-identity-of-an-evm-address-on-near"},"The identity of an EVM address on NEAR"),(0,r.kt)("p",null,"Many NEAR contracts (especially financial ones) differentiate between the NEAR accounts that call them.\nTherefore, it is important for each address using XCC to be distinguished from one another in NEAR.\nThis is accomplished by the XCC precompile creating a NEAR account on behalf of each address that uses the feature.\nIf address ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," uses XCC on Aurora (which has account ",(0,r.kt)("inlineCode",{parentName:"p"},"aurora")," on NEAR) then a new account ",(0,r.kt)("inlineCode",{parentName:"p"},"A.aurora")," will be created.\nThis account includes a small smart contract which accepts data from the Aurora EVM to construct and execute the NEAR call.\nThis way the NEAR contract being called will see ",(0,r.kt)("inlineCode",{parentName:"p"},"A.aurora")," as the predecessor account."),(0,r.kt)("p",null,"This sub-account is the reason why 2 wNEAR is needed on the first XCC invocation.\nIt is used to cover the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.near.org/concepts/storage/storage-staking"},"storage staking")," cost of the account and its contract."),(0,r.kt)("h3",{id:"getting-the-result-of-a-near-call"},"Getting the result of a NEAR call"),(0,r.kt)("p",null,"As mentioned above, the only way to get the result of a NEAR call back to the EVM is using a callback.\nSpecifically, this must be done via the ",(0,r.kt)("inlineCode",{parentName:"p"},"call")," method of the Aurora Engine (this is the method which is used by NEAR contracts to interact with the EVM).\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"submit")," method cannot be used because it accepts signed EVM transactions only and generating such input inside an EVM transaction would not be secure since the private key would be available\nto anyone that introspected the contract."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"call")," method can be used by any NEAR contract to interact with the EVM, not just the special sub-accounts created by XCC.\nThe mechanism the ",(0,r.kt)("inlineCode",{parentName:"p"},"call")," method uses to assign an EVM address to the predecessor account ID is the same for all accounts (no special case is made for XCC sub-accounts).\nThis leads to the quirk we mentioned above that the sender address in the callback is not equal to the address that initiated the XCC.\nThe way the address is calculated is by taking the last 20 bytes of the keccak hash of the NEAR account ID\n(see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/aurora-is-near/aurora-engine/blob/2.8.1/engine-sdk/src/types.rs#L25-L27"},"Aurora contract code"),").\n20-byte addresses are standard in Ethereum, and are derivied from the public key of the account in the same way as we derive an address from a Near account ID\n(taking the last 20 bytes of the keccak hash).\nTherefore, we do not concern ourselves with the possibility of an address collision.\nIt would be quite a difficult proof of work problem to find two account IDs that give the same EVM address, and the probability of it happening randomly is incredibly low!"),(0,r.kt)("h3",{id:"the-data-structures-used-by-xcc"},"The data structures used by XCC"),(0,r.kt)("p",null,"The XCC precompile accepts borsh-encoded data of the following type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"/// The XCC request can be `Eager` or `Delayed`.\n/// In an `Eager` request, the call will happen automatically after the EVM execution is finished.\n/// In a `Delayed` request the data to make the NEAR call is persisted in the address' sub-account\n/// (the sub-account for each address concept is discussed above).\n/// The benefit of `Eager` over `Delayed` is that the NEAR call happens automatically without the\n/// need for any other NEAR account.\n/// The benefit of `Delayed` is that more complex behavior is possible because the total gas limit\n/// on NEAR is reset between transactions.\n/// To elaborate on that a little more, there is a maximum amount of gas that is allowed to be\n/// attached to a NEAR transaction (at the time of writing it is 300 Tgas), and each asynchronous\n/// call requires some gas to be attached to it from that initial amount in the transaction.\n/// Therefore, if there is some complicated EVM logic followed by a cross-contract call to some\n/// complicated NEAR logic then it may not be possible to fit all that within the gas limit.\n/// Using a `Delayed` XCC request effectively doubles the amount of gas available because the EVM\n/// execution will happen in a separate transaction (with a separate gas limit) from the subsequent NEAR execution.\npub enum CrossContractCallArgs {\n    Eager(PromiseArgs),\n    Delayed(PromiseArgs),\n}\n\n/// describes the NEAR call to be performed\npub enum PromiseArgs {\n    /// A call to a single NEAR contract.\n    Create(PromiseCreateArgs),\n    /// A NEAR call with single callback.\n    /// This is useful to make a single NEAR call and then callback to Aurora, for example.\n    Callback(PromiseWithCallbackArgs),\n    /// A recursive data type that captures arbitrary promise combinators (`then`, `and` are\n    /// promise combinators because they combine multiple promises into a single promise).\n    Recursive(NearPromise),\n}\n\npub struct PromiseCreateArgs {\n    pub target_account_id: AccountId,\n    pub method: String,\n    pub args: Vec<u8>,\n    pub attached_balance: Yocto,\n    pub attached_gas: NearGas,\n}\n\npub struct PromiseWithCallbackArgs {\n    pub base: PromiseCreateArgs,\n    pub callback: PromiseCreateArgs,\n}\n\npub enum NearPromise {\n    Simple(SimpleNearPromise),\n    Then {\n        base: Box<NearPromise>,\n        callback: SimpleNearPromise,\n    },\n    And(Vec<NearPromise>),\n}\n\npub enum SimpleNearPromise {\n    Create(PromiseCreateArgs),\n    Batch(PromiseBatchAction),\n}\n\npub struct PromiseBatchAction {\n    pub target_account_id: AccountId,\n    pub actions: Vec<PromiseAction>,\n}\n\npub enum PromiseAction {\n    CreateAccount,\n    Transfer {\n        amount: Yocto,\n    },\n    // ... (elided)\n}\n")),(0,r.kt)("p",null,"For most applications the ",(0,r.kt)("inlineCode",{parentName:"p"},"PromiseWithCallbackArgs")," should be sufficient.\nIf your application needs the more general ",(0,r.kt)("inlineCode",{parentName:"p"},"NearPromise")," then see the ",(0,r.kt)("a",{parentName:"p",href:"https://nomicon.io/RuntimeSpec/Components/BindingsSpec/PromisesAPI"},"NEAR documentation")," for more information."))}d.isMDXComponent=!0},8818:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/aurora-near-xcc-0c208dffeccbabaa41ea9d28333e854b.avif"}}]);